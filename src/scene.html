<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/lights/DirectionalLight.js"></script>

		<script>
			// Global variables
			var snakeCubeArray = [];
			var treePositions = [];
			var snakeForwardDirection = new THREE.Vector3(1,0,0);
			var clock = new THREE.Clock(true);
			var elapsedTime = 0;
			var tickDelta = 0.25; // 250ms
			var squareSize = 25; // must be odd
			var treeDensity = 0.02;
			var numberOfTrees = squareSize*squareSize*treeDensity;
			var gameLost = false;
			var appleMeshArray = [];

			// view = 0 for initial view, 1 for view from top and 2 for third person
			var view = 0;

			// TODO: Remove when apples are added to the scene
			// This variable is used to simulate an apple eaten with the space bar
			var appleEaten = false;

			// Debug or not
			var debug = false;

			// Create the scene
			var scene = new THREE.Scene();

			// Add scene elements
			addSceneElements();

			// Add Snake
			initializeSnake();

			// Add the camera
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.set(0, -30, 30);
			camera.lookAt(scene.position);
			scene.add(camera); 

			// Add lights
			addLights();

			// Create the WebGL renderer
			var renderer = new THREE.WebGLRenderer();
			var scaleFactor = 0.99
			renderer.setSize( window.innerWidth*scaleFactor, window.innerHeight*scaleFactor );
			renderer.shadowMapEnabled = true;

			// Append the renderer to the body
			document.body.appendChild( renderer.domElement );

			document.onkeydown = checkKey;

			render();

			// Main functions
			function addSceneElements()
			{
				// Create the ground
				var groundGeometry = new THREE.BoxGeometry( squareSize, squareSize, 0.2 );
				var groundMaterial = new THREE.MeshBasicMaterial( { color: 0x5FB404 } );
				var ground = new THREE.Mesh( groundGeometry, groundMaterial );
				ground.receiveShadow = true;
				scene.add( ground );

				//Add trees
				//(radiusTop, radiusBottom, height)
				var geometryTrunk = new THREE.CylinderGeometry( 0.1, 0.5, 2);
				var materialTrunk = new THREE.MeshBasicMaterial( {color: 0x4d2600} );

				var geometrySphere = new THREE.SphereGeometry(1);
				var materialSphere = new THREE.MeshBasicMaterial( {color: 0x009900} );
				var zTree = 1;
				for (var i=0;i<numberOfTrees;i++)
				{
					var mx = Math.round((Math.random()-0.5)*(squareSize-1));
					var my = Math.round((Math.random()-0.5)*(squareSize-1));
					treePositions.push(new THREE.Vector2(mx, my));

					var trunk = new THREE.Mesh( geometryTrunk, materialTrunk );
					trunk.position.x=mx;
					trunk.position.y=my;
					trunk.position.z=zTree;
					trunk.rotation.x = Math.PI / 2;
					scene.add( trunk );

					var sphere = new THREE.Mesh( geometrySphere, materialSphere );
					sphere.position.x=mx;
					sphere.position.y=my;
					sphere.position.z = zTree + 2;
					scene.add( sphere );
				}

				// First apple
				addApple();
			}

			function initializeSnake()
			{
				// Create the snake
				var cubeGeometry = new THREE.BoxGeometry( 1, 1, 1 );
				var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xffff00 } );

				var initialSnakeLength = 3;
				for (var i = 0; i < initialSnakeLength; i++)
				{
					var cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
					cube.position.set(initialSnakeLength-i, 0, 0.5);
					snakeCubeArray.push(cube);
					scene.add(snakeCubeArray[i]);
				}
			}

			function checkTreeCollision(objectPosition)
			{
				for(var i=0 ; i < treePositions.length ; i++)
				{
					if(objectPosition.x == treePositions[i].x
					   && objectPosition.y == treePositions[i].y)
					{
						return true;
					}
				}
				return false;
			}

			function checkWallCollision(objectPosition)
			{
				if(objectPosition.x >= squareSize/2
				   || objectPosition.x <= -squareSize/2
				   || objectPosition.y >= squareSize/2
				   || objectPosition.y <= -squareSize/2 )
				{
					return true;
				}
				return false;
			}

			function checkItemEaten(objectPosition)
			{
				for(var i=0 ; i < appleMeshArray.length ; i++)
				{
					if(objectPosition.x == appleMeshArray[i].position.x
					   && objectPosition.y == appleMeshArray[i].position.y)
					{
						// Remove the eaten apple from the scene
						scene.remove(appleMeshArray[i]);
						// Remove the eaten apple from the array
						appleMeshArray.splice(i,1);
						// Add a new apple
						addApple();
						// Increase speed
						tickDelta *= 0.95;
						return true;
					}
				}
				return false;
			}

			function moveSnakeForward()
			{
				// Check if the snake is eating something
				// Increment snake length
				if(checkItemEaten(snakeCubeArray[0].position) == true)
				{
// 					var cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
					var cube = new THREE.Mesh( snakeCubeArray[0].geometry, snakeCubeArray[0].material );
					snakeCubeArray.splice(0, 0, cube);
					scene.add(snakeCubeArray[0]);
				}
				else
				{
					// Put the last piece in the front
					snakeCubeArray.splice(0, 0, snakeCubeArray.pop());
				}
					// Move head in the forward forwardDirection
					snakeCubeArray[0].position.copy(snakeCubeArray[1].position);
					snakeCubeArray[0].position.add(snakeForwardDirection);

			}

			function addApple()
			{
				// Create an apple
				var geometry = new THREE.SphereGeometry( 0.5, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
				var sphere = new THREE.Mesh( geometry, material );
				do
				{
					sphere.position.x = Math.round((Math.random()-0.5)*(squareSize-1));
					sphere.position.y = Math.round((Math.random()-0.5)*(squareSize-1));
					sphere.position.z = 0.5;
				}
				while(checkTreeCollision(sphere.position));

				appleMeshArray.push(sphere);
				scene.add( sphere );
			}

			function addLights()
			{
				if(debug == true)
				{
					console.log('test');
				}
				// Ambient light has no direction, it illuminates every object with the same 
				// intensity. If only ambient light is used, no shading effects will occur. 
				var ambientLight = new THREE.AmbientLight(0x101010, 1.0); 
				scene.add(ambientLight);   

				// Directional light has a source and shines in all directions, like the sun. 
				// This behaviour creates shading effects. 
				directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
				directionalLight.position.set(5.0, 5.0, 10.0); 
				directionalLight.castShadow = true;
				directionalLight.shadowCameraNear = true;
				directionalLight.shadowCameraVisible = true;
				directionalLight.shadowDarkness = 0.5;
				scene.add(directionalLight);
			}

			function changeView(view)
			{
				if(view==0)
				{
					camera.position.set(0, -30, 30);
					camera.lookAt(scene.position);
					scene.add(camera); 
				}
				else if(view==1)
				{
					camera.position.set(0, 0, 30);
					camera.lookAt(scene.position);
					scene.add(camera); 
				}
				else
				{

				}
			}

			function checkKey(e) 
			{
				e = e || window.event;
				var distance = 1;

				if (e.keyCode == '90')
				{
					// z
					if(debug == true)
					{
						console.log('z');
					}
					camera.translateY(-distance);
				}
				else if (e.keyCode == '83')
				{
					// s
					if(debug == true)
					{
						console.log('s');
					}
					camera.translateY(distance);
				}
				else if (e.keyCode == '81')
				{
					// q
					if(debug == true)
					{
						console.log('q');
					}
				      camera.translateX(distance);
				}
				else if (e.keyCode == '68')
				{
					// d
					if(debug == true)
					{
						console.log('d');
					}
					camera.translateX(-distance);
				}
				else if (e.keyCode == '37')
				{
					// LEFT ARROW
					if(debug == true)
					{
						console.log('left arrow');
					}
					if(snakeForwardDirection.x != 1)
					{
						snakeForwardDirection.set(-1,0,0);
					}
				}
				else if (e.keyCode == '38')
				{
					// UP ARROW
					if(debug == true)
					{
						console.log('up arrow');
					}
					if(snakeForwardDirection.y != -1)
					{
						snakeForwardDirection.set(0,1,0);
					}
				}
				else if (e.keyCode == '39')
				{
					// RIGHT ARROW
					if(debug == true)
					{
						console.log('right arrow');
					}
					if(snakeForwardDirection.x != -1)
					{
						snakeForwardDirection.set(1,0,0);
					}
				}
				else if (e.keyCode == '40')
				{
					// DOWN ARROW
					if(debug == true)
					{
						console.log('down arrow');
					}
					if(snakeForwardDirection.y != 1)
					{
						snakeForwardDirection.set(0,-1,0);
					}
				}
				else if (e.keyCode == '32')
				{
					// SPACE BAR
					if(debug == true)
					{
						console.log('space bar');
					}
					// TODO: Remove this when apples are added on the scene
					appleEaten = true;
				}
				else if (e.keyCode == '80')
				{
					// P
					if(debug == true)
					{
						console.log('P');
					}
					// Change view
					view = (view+1)%3;
					changeView(view);
				}
			}

			function render()
			{
				requestAnimationFrame( render );
				console.log(gameLost);
				if( gameLost == false)
				{
					elapsedTime += clock.getDelta();
				}
				else
				{
					// TODO : Display the losing screen
					console.log("You lost");
				}

				if( elapsedTime > tickDelta)
				{
					moveSnakeForward();
					gameLost = checkTreeCollision(snakeCubeArray[0].position)
						   || checkWallCollision(snakeCubeArray[0].position);

					elapsedTime = 0.0;
				}
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
